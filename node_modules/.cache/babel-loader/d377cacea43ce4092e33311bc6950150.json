{"ast":null,"code":"import React from 'react';\nimport PropTypes from 'prop-types';\n\nvar stripHtml = function stripHtml(element) {\n  return element.innerHTML.replace(/<[^>]*>?/gm, '');\n};\n\nvar parseStrDimensionToInt = function parseStrDimensionToInt(elementSize) {\n  return parseInt(elementSize, 10);\n};\n\nvar getOffset = function getOffset(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    top: rect.top + document.body.scrollTop,\n    left: rect.left + document.body.scrollLeft\n  };\n};\n\nvar index = function index(element) {\n  var children = element.parentNode.childNodes;\n  var num = 0;\n\n  for (var i = 0; i < children.length; i++) {\n    if (children[i] === element) return num;\n    if (children[i].nodeType === 1) num++;\n  }\n\n  return -1;\n};\n\nvar getAttribute = function getAttribute(element, attributeName) {\n  return element.getAttribute(attributeName);\n};\n\nvar addClass = function addClass(element, className) {\n  if (element.classList) element.classList.add(className);else element.className += ' ' + className;\n};\n\nvar removeClass = function removeClass(element, className) {\n  if (element.classList) element.classList.remove(className);else {\n    element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n  }\n};\n\nvar hasClass = function hasClass(element, className) {\n  if (element.classList) return element.classList.contains(className);else return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\n};\n\nvar findFirstChildWithClassName = function findFirstChildWithClassName(element, className) {\n  var matches = element.getElementsByClassName(className);\n  if (matches && matches.length > 0) return matches[0];\n  return null;\n};\n\nvar findChildrenWithClassName = function findChildrenWithClassName(parentElement, className) {\n  return parentElement.getElementsByClassName(className);\n};\n\nvar getHiddenElementOuterHeight = function getHiddenElementOuterHeight(element) {\n  element.style.visibility = 'hidden';\n  element.style.display = 'block';\n  var elementHeight = element.offsetHeight;\n  element.style.display = 'none';\n  element.style.visibility = 'visible';\n  return elementHeight;\n};\n\nvar getHiddenElementOuterWidth = function getHiddenElementOuterWidth(element) {\n  element.style.visibility = 'hidden';\n  element.style.display = 'block';\n  var elementWidth = element.offsetWidth;\n  element.style.display = 'none';\n  element.style.visibility = 'visible';\n  return elementWidth;\n};\n\nvar getElementWidth = function getElementWidth(el) {\n  var width = el.offsetWidth;\n  var style = getComputedStyle(el);\n  width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);\n  return width;\n};\n\nvar getElementHeight = function getElementHeight(el) {\n  var height = el.offsetHeight;\n  var style = getComputedStyle(el);\n  height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);\n  return height;\n};\n\nvar DomHelper = {\n  stripHtml: stripHtml,\n  parseStrDimensionToInt: parseStrDimensionToInt,\n  getOffset: getOffset,\n  index: index,\n  getAttribute: getAttribute,\n  addClass: addClass,\n  removeClass: removeClass,\n  hasClass: hasClass,\n  getHiddenElementOuterHeight: getHiddenElementOuterHeight,\n  getHiddenElementOuterWidth: getHiddenElementOuterWidth,\n  findFirstChildWithClassName: findFirstChildWithClassName,\n  findChildrenWithClassName: findChildrenWithClassName,\n  getElementWidth: getElementWidth,\n  getElementHeight: getElementHeight\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar DragMode = {\n  REORDER: 'reorder',\n  SWAP: 'swap'\n  /**\n   * Generate UuId\n   * */\n\n};\n\nvar generateUuid = function generateUuid() {\n  var uuid = '';\n  var i = void 0;\n  var random = void 0;\n\n  for (i = 0; i < 32; i++) {\n    random = Math.random() * 16 | 0;\n\n    if (i === 8 || i === 12 || i === 16 || i === 20) {\n      uuid += '-';\n    }\n\n    uuid += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\n  }\n\n  return uuid;\n};\n\nvar index$1 = function (Component) {\n  var wrapper = function (_React$Component) {\n    inherits(RTFixedDraggableColumn, _React$Component);\n    createClass(RTFixedDraggableColumn, [{\n      key: 'getWrappedInstance',\n      value: function getWrappedInstance() {\n        if (!this.wrappedInstance) console.warn('RTDraggableColumn - No wrapped instance');\n        if (this.wrappedInstance.getWrappedInstance) return this.wrappedInstance.getWrappedInstance();else return this.wrappedInstance;\n      }\n    }]);\n\n    function RTFixedDraggableColumn(props) {\n      classCallCheck(this, RTFixedDraggableColumn);\n\n      var _this = possibleConstructorReturn(this, (RTFixedDraggableColumn.__proto__ || Object.getPrototypeOf(RTFixedDraggableColumn)).call(this, props));\n\n      _this.containerRef = React.createRef();\n      _this.currentColumnOrder = [];\n\n      _this.stopPropagation = function (e) {\n        e.stopPropagation();\n      };\n\n      _this.dragged = null;\n      _this.reorder = [];\n      _this.colsNoExtraContainingDiv = [];\n      _this.state = {\n        trigger: 0,\n        firstLoad: true\n      };\n      _this.uniqueId = generateUuid();\n      return _this;\n    } // helper methods\n\n\n    createClass(RTFixedDraggableColumn, [{\n      key: 'findParentHeader',\n      value: function findParentHeader(element) {\n        // need to check typeof to avoid errors when traversing special elements like SVGs\n        if (element.className && typeof element.className === 'string' && element.className.includes('rt-th')) {\n          return element;\n        } else {\n          var parent = element.parentElement;\n\n          while (typeof parent.className !== 'string' || !parent.className.includes('rt-th')) {\n            parent = parent.parentElement;\n            if (!parent) break;\n          }\n\n          return parent;\n        }\n      }\n    }, {\n      key: 'getFirstChildWithColumnIndexAttributeValue',\n      value: function getFirstChildWithColumnIndexAttributeValue(element) {\n        var header = DomHelper.findFirstChildWithClassName(element, 'draggable-header');\n\n        if (header) {\n          return DomHelper.getAttribute(header, 'data-column-index');\n        }\n      } // end helper methods\n\n    }, {\n      key: 'createDragEvents',\n      value: function createDragEvents() {\n        var _this2 = this;\n\n        var headersCollection = DomHelper.findChildrenWithClassName(this.containerRef.current, this.uniqueId + ' draggable-header'); // convert HTML collection to Javascript array\n\n        var headers = [].concat(toConsumableArray(headersCollection));\n        headers.forEach(function (header, i) {\n          // only allow drag events on drag enabled columns\n          if (header.className.includes('enable-drag')) {\n            var headerParent = header.parentNode;\n            var _props$draggableColum = _this2.props.draggableColumns.enableColumnWideDrag,\n                enableColumnWideDrag = _props$draggableColum === undefined ? defaultProps.enableColumnWideDrag : _props$draggableColum;\n\n            if (enableColumnWideDrag) {\n              headerParent.setAttribute('draggable', true);\n            } else {\n              header.setAttribute('draggable', true);\n              DomHelper.addClass(headerParent, 'transparent-border');\n            } // ondragstart event\n\n\n            headerParent.ondragstart = function (e) {\n              e.stopPropagation();\n              var _props$draggableColum2 = _this2.props.draggableColumns,\n                  disableTableScroll = _props$draggableColum2.disableTableScroll,\n                  _props$draggableColum3 = _props$draggableColum2.useDragImage,\n                  useDragImage = _props$draggableColum3 === undefined ? defaultProps.useDragImage : _props$draggableColum3,\n                  _props$draggableColum4 = _props$draggableColum2.dragImageClassName,\n                  dragImageClassName = _props$draggableColum4 === undefined ? defaultProps.dragImageClassName : _props$draggableColum4;\n\n              if (disableTableScroll) {\n                var tableBody = DomHelper.findFirstChildWithClassName(_this2.containerRef.current, 'rt-table');\n\n                if (tableBody) {\n                  tableBody.style.overflow = 'hidden';\n                }\n              } // counter used as a workaround for dragleave event fired when hovering over a child element\n\n\n              _this2.counter = 0;\n              _this2.dragged = i;\n              _this2.draggedName = DomHelper.stripHtml(headerParent);\n              _this2.draggedColumn = _this2.findParentHeader(headerParent);\n              _this2.iconWidth = DomHelper.getHiddenElementOuterWidth(_this2.reorderIndicatorUp);\n              _this2.iconHeight = DomHelper.getHiddenElementOuterHeight(_this2.reorderIndicatorUp);\n              e.dataTransfer.setData('text', 'b'); // Firefox requires this to make dragging possible\n\n              if (useDragImage) {\n                var crt = _this2.draggedColumn.cloneNode(true);\n\n                crt.className = dragImageClassName;\n                var columnWidth = DomHelper.getElementWidth(_this2.draggedColumn);\n                var columnHeight = DomHelper.getElementHeight(_this2.draggedColumn); // calculate offset from draggedColumn element\n\n                var xOffSet = Math.floor(columnWidth / 2);\n                var yOffSet = Math.floor(columnHeight / 2); // max-width of 150px, otherwise it looks blurry in Chrome (Windows)\n\n                if (columnWidth > 150) {\n                  crt.style.width = '150px';\n                  xOffSet = 150 / 2;\n                }\n\n                crt.style.position = 'absolute';\n                crt.style.top = '-1000px';\n                document.body.appendChild(crt);\n                e.dataTransfer.effectAllowed = 'move';\n                e.dataTransfer.setDragImage(crt, xOffSet, yOffSet); // set refernce to cloned Node\n\n                _this2.clone = crt;\n              }\n            }; // ondrag event\n\n\n            headerParent.ondrag = function (e) {\n              e.stopPropagation();\n            };\n\n            headerParent.ondragenter = function (e) {\n              e.stopPropagation();\n              e.preventDefault();\n              _this2.counter++;\n\n              if (DomHelper.stripHtml(e.target) !== _this2.draggedName) {\n                var _props$draggableColum5 = _this2.props.draggableColumns,\n                    _props$draggableColum6 = _props$draggableColum5.mode,\n                    mode = _props$draggableColum6 === undefined ? defaultProps.mode : _props$draggableColum6,\n                    _props$draggableColum7 = _props$draggableColum5.onDragEnterClassName,\n                    onDragEnterClassName = _props$draggableColum7 === undefined ? defaultProps.onDragEnterClassName : _props$draggableColum7;\n\n                if (mode === DragMode.SWAP && onDragEnterClassName) {\n                  var dropHeader = _this2.findParentHeader(e.target);\n\n                  DomHelper.addClass(dropHeader.firstChild, onDragEnterClassName);\n                }\n              }\n            }; // ondragover event\n\n\n            headerParent.ondragover = function (e) {\n              e.preventDefault(); // prevent bug when using multiple react tables\n\n              if (!_this2.draggedColumn) return;\n              var _props$draggableColum8 = _this2.props.draggableColumns.mode,\n                  mode = _props$draggableColum8 === undefined ? defaultProps.mode : _props$draggableColum8;\n\n              var dropHeader = _this2.findParentHeader(e.target); // in reorder mode only\n\n\n              if (mode === DragMode.REORDER) {\n                if (DomHelper.stripHtml(e.target) !== _this2.draggedName) {\n                  var containerOffset = DomHelper.getOffset(_this2.containerRef.current);\n                  var dropHeaderOffset = DomHelper.getOffset(dropHeader);\n                  var targetLeft = dropHeaderOffset.left - containerOffset.left;\n                  var columnCenter = dropHeaderOffset.left + dropHeader.offsetWidth / 2;\n                  var tableBodyBoundingRec = DomHelper.findFirstChildWithClassName(_this2.containerRef.current, 'rt-table').getBoundingClientRect(); // determine current table viewport\n\n                  var maxVisibleXPos = tableBodyBoundingRec.right;\n                  var minVisibleXPos = 0 - Math.ceil(_this2.iconWidth / 2);\n                  _this2.reorderIndicatorUp.style.top = dropHeaderOffset.top - containerOffset.top - (_this2.iconHeight + 3) + 'px';\n                  _this2.reorderIndicatorDown.style.top = dropHeaderOffset.top - containerOffset.top + dropHeader.offsetHeight + 3 + 'px';\n\n                  if (e.pageX > columnCenter) {\n                    _this2.reorderIndicatorUp.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(_this2.iconWidth / 2) + 'px';\n                    _this2.reorderIndicatorDown.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(_this2.iconWidth / 2) + 'px';\n                    _this2.dropPosition = 1;\n                  } else {\n                    _this2.reorderIndicatorUp.style.left = targetLeft - Math.ceil(_this2.iconWidth / 2) + 'px';\n                    _this2.reorderIndicatorDown.style.left = targetLeft - Math.ceil(_this2.iconWidth / 2) + 'px';\n                    _this2.dropPosition = -1;\n                  }\n\n                  if (DomHelper.parseStrDimensionToInt(_this2.reorderIndicatorUp.style.left) > maxVisibleXPos || DomHelper.parseStrDimensionToInt(_this2.reorderIndicatorUp.style.left) < minVisibleXPos) {\n                    // do not show indicators if position is outside leftmost or rightmost bounds of the react table\n                    _this2.reorderIndicatorUp.style.display = 'none';\n                    _this2.reorderIndicatorDown.style.display = 'none';\n                  } else {\n                    _this2.reorderIndicatorUp.style.display = 'block';\n                    _this2.reorderIndicatorDown.style.display = 'block';\n                    _this2.reorderIndicatorUp.style.zIndex = 50;\n                    _this2.reorderIndicatorDown.style.zIndex = 50;\n                  }\n                }\n              }\n            };\n\n            headerParent.ondragleave = function (e) {\n              e.preventDefault();\n              _this2.counter--;\n              var _props$draggableColum9 = _this2.props.draggableColumns,\n                  _props$draggableColum10 = _props$draggableColum9.mode,\n                  mode = _props$draggableColum10 === undefined ? defaultProps.mode : _props$draggableColum10,\n                  _props$draggableColum11 = _props$draggableColum9.onDragEnterClassName,\n                  onDragEnterClassName = _props$draggableColum11 === undefined ? defaultProps.onDragEnterClassName : _props$draggableColum11;\n\n              if (mode === DragMode.REORDER) {\n                if (_this2.counter === 0) {\n                  _this2.reorderIndicatorUp.style.display = 'none';\n                  _this2.reorderIndicatorDown.style.display = 'none';\n                }\n              } else if (mode === DragMode.SWAP) {\n                if (_this2.counter === 0 && onDragEnterClassName) {\n                  var dropHeader = _this2.findParentHeader(e.target);\n\n                  DomHelper.removeClass(dropHeader.firstChild, onDragEnterClassName);\n                }\n              }\n            }; // ondrop event\n\n\n            headerParent.ondrop = function (e) {\n              e.preventDefault(); // prevent bug when using multiple react tables\n\n              if (!_this2.draggedColumn) return;\n              var _props$draggableColum12 = _this2.props.draggableColumns,\n                  _props$draggableColum13 = _props$draggableColum12.mode,\n                  mode = _props$draggableColum13 === undefined ? defaultProps.mode : _props$draggableColum13,\n                  onDropSuccess = _props$draggableColum12.onDropSuccess;\n\n              if (mode === DragMode.REORDER) {\n                // only move if the dragged column is meets position threshold\n                var dragIndex = DomHelper.index(_this2.draggedColumn);\n                var dropIndex = DomHelper.index(_this2.findParentHeader(e.target)); // for the future\n                // this.getFirstChildWithColumnIndexAttributeValue(this.draggedColumn)\n\n                var allowDrop = dragIndex !== dropIndex;\n\n                if (allowDrop && (dropIndex - dragIndex === 1 && _this2.dropPosition === -1 || dragIndex - dropIndex === 1 && _this2.dropPosition === 1)) {\n                  allowDrop = false;\n                }\n\n                if (allowDrop) {\n                  // readjust dropIndex value for edge cases\n                  // if dragging a column from left to right\n                  if (_this2.dragged < dropIndex) {\n                    if (_this2.dropPosition === -1) {\n                      dropIndex = dropIndex - 1;\n                    }\n                  } else {\n                    // dragging a column from right to left\n                    if (_this2.dropPosition === 1) {\n                      dropIndex = dropIndex + 1;\n                    }\n                  }\n\n                  _this2.reorder.push({\n                    a: dropIndex,\n                    b: _this2.dragged\n                  });\n\n                  if (onDropSuccess) {\n                    var containerOffset = DomHelper.getOffset(_this2.containerRef.current); // adjust offSets to be respective to the containerOffset\n\n                    var oldOffset = DomHelper.getOffset(_this2.draggedColumn);\n                    oldOffset.top = oldOffset.top - containerOffset.top;\n                    oldOffset.left = oldOffset.left - containerOffset.left;\n                    var newOffset = DomHelper.getOffset(_this2.findParentHeader(e.target));\n                    newOffset.top = newOffset.top - containerOffset.top;\n                    newOffset.left = newOffset.left - containerOffset.left; // (draggedColumn, targetColumn, oldIndex, newIndex, oldOffset, newOffset)\n\n                    onDropSuccess(_this2.colsNoExtraContainingDiv[_this2.dragged], _this2.colsNoExtraContainingDiv[dropIndex], _this2.dragged, dropIndex, oldOffset, newOffset);\n                  }\n                }\n              } else if (mode === DragMode.SWAP) {\n                _this2.reorder.push({\n                  a: i,\n                  b: _this2.dragged\n                });\n\n                if (onDropSuccess) {\n                  // (draggedColumn, targetColumn, oldIndex, newIndex)\n                  onDropSuccess(_this2.currentColumnOrder[_this2.dragged], _this2.currentColumnOrder[i], _this2.dragged, i);\n                }\n              }\n\n              _this2.dragged = null;\n              _this2.draggedName = null;\n              _this2.draggedColumn = null;\n              _this2.dropPosition = null;\n              _this2.counter = 0;\n              _this2.reorderIndicatorUp.style.display = 'none';\n              _this2.reorderIndicatorDown.style.display = 'none'; // trigger a re-render\n\n              _this2.setState({\n                trigger: Math.random(),\n                firstLoad: false\n              });\n            }; // ondragend event\n\n\n            headerParent.ondragend = function (e) {\n              var _props$draggableColum14 = _this2.props.draggableColumns,\n                  disableTableScroll = _props$draggableColum14.disableTableScroll,\n                  overflow = _props$draggableColum14.overflow;\n              e.stopPropagation();\n\n              if (_this2.clone) {\n                document.body.removeChild(_this2.clone);\n                _this2.clone = null;\n              }\n\n              if (disableTableScroll) {\n                var tableBody = DomHelper.findFirstChildWithClassName(_this2.containerRef.current, 'rt-table');\n\n                if (tableBody) {\n                  tableBody.style.overflow = overflow || defaultProps.overflow;\n                }\n              }\n            };\n          }\n        });\n      }\n    }, {\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        if (this.props.draggableColumns.draggable.length > 0) this.createDragEvents();\n      }\n    }, {\n      key: 'componentDidUpdate',\n      value: function componentDidUpdate() {\n        var onDraggedColumnChange = this.props.draggableColumns.onDraggedColumnChange;\n\n        if (!this.state.firstLoad) {\n          var originalOrder = this.previousOrder.map(function (col) {\n            if (typeof col.accessor === 'function') return col.id;\n            return col.accessor;\n          });\n          var newOrder = this.currentColumnOrder.map(function (col) {\n            if (typeof col.accessor === 'function') return col.id;\n            return col.accessor;\n          }); // if order is not equal, then call onDraggedColumnChange prop\n\n          if (JSON.stringify(originalOrder) !== JSON.stringify(newOrder)) {\n            // pass back updated order of columns without added containing drag DIV\n            if (onDraggedColumnChange) {\n              onDraggedColumnChange(this.colsNoExtraContainingDiv);\n            }\n          }\n        }\n\n        if (this.props.draggableColumns.draggable.length > 0) this.createDragEvents();\n      } // prevent side effects such as accidentally resizing column while dragging a column\n\n    }, {\n      key: 'render',\n      value: function render() {\n        var _this3 = this;\n\n        var _props = this.props,\n            origColumns = _props.columns,\n            draggableColumns = _props.draggableColumns,\n            rest = objectWithoutProperties(_props, ['columns', 'draggableColumns']);\n        var _draggableColumns$dra = draggableColumns.draggable,\n            draggable = _draggableColumns$dra === undefined ? defaultProps.draggable : _draggableColumns$dra,\n            _draggableColumns$mod = draggableColumns.mode,\n            mode = _draggableColumns$mod === undefined ? defaultProps.mode : _draggableColumns$mod,\n            _draggableColumns$reo = draggableColumns.reorderIndicatorUpClassName,\n            reorderIndicatorUpClassName = _draggableColumns$reo === undefined ? defaultProps.reorderIndicatorUpClassName : _draggableColumns$reo,\n            _draggableColumns$reo2 = draggableColumns.reorderIndicatorDownClassName,\n            reorderIndicatorDownClassName = _draggableColumns$reo2 === undefined ? defaultProps.reorderIndicatorDownClassName : _draggableColumns$reo2;\n        var reorderIndicatorUp = React.createElement('span', {\n          ref: function ref(el) {\n            _this3.reorderIndicatorUp = el;\n          },\n          className: 'arrow arrow-bar is-top ' + reorderIndicatorUpClassName,\n          style: {\n            position: 'absolute',\n            display: 'none'\n          }\n        });\n        var reorderIndicatorDown = React.createElement('span', {\n          ref: function ref(el) {\n            _this3.reorderIndicatorDown = el;\n          },\n          className: 'arrow arrow-bar is-bottom ' + reorderIndicatorDownClassName,\n          style: {\n            position: 'absolute',\n            display: 'none'\n          }\n        }); // separate out visible and hidden columns\n\n        var visibleColumns = origColumns.filter(function (col) {\n          return col.show === true || col.show === undefined;\n        });\n        var hiddenColumns = origColumns.filter(function (col) {\n          return col.show === false;\n        }); // place hidden columns at very end of array\n        // having a hidden column inbetween two draggable columns will cause this HOC to improperly calculate the new column index positions\n\n        var adjustedOrigColumns = [].concat(toConsumableArray(visibleColumns), toConsumableArray(hiddenColumns)); // shallow copy of columns without added containing drag DIV\n\n        this.colsNoExtraContainingDiv = [].concat(toConsumableArray(adjustedOrigColumns));\n        var cols = adjustedOrigColumns.map(function (col, index) {\n          var headerClassName = _this3.uniqueId + ' draggable-header'; // add additional className if column is draggable enabled\n\n          if (draggable.length > 0 && draggable.includes(col.id) || draggable.includes(col.accessor)) {\n            headerClassName = headerClassName + ' enable-drag';\n          }\n\n          return _extends({}, col, {\n            Header: typeof col.Header === 'function' ? React.createElement('div', {\n              className: headerClassName,\n              'data-column-index': index\n            }, col.Header()) : React.createElement('div', {\n              className: headerClassName,\n              'data-column-index': index\n            }, col.Header)\n          });\n        }); //const previousOrder = [...this.currentColumnOrder]\n\n        this.previousOrder = [].concat(toConsumableArray(this.currentColumnOrder)); // run all reorder events\n\n        if (mode && mode === DragMode.SWAP) {\n          this.reorder.forEach(function (o) {\n            return cols[o.a] = cols.splice(o.b, 1, cols[o.a])[0];\n          });\n          this.reorder.forEach(function (o) {\n            return _this3.colsNoExtraContainingDiv[o.a] = _this3.colsNoExtraContainingDiv.splice(o.b, 1, _this3.colsNoExtraContainingDiv[o.a])[0];\n          });\n        } else {\n          // mode: reorder - default\n          this.reorder.forEach(function (o) {\n            return cols.splice(o.a, 0, cols.splice(o.b, 1)[0]);\n          });\n          this.reorder.forEach(function (o) {\n            return _this3.colsNoExtraContainingDiv.splice(o.a, 0, _this3.colsNoExtraContainingDiv.splice(o.b, 1)[0]);\n          });\n        } // track final column order\n\n\n        this.currentColumnOrder = cols; // fire change event?\n\n        /*  if (!this.state.firstLoad) {\n            const originalOrder = this.previousOrder.map(col => {\n              if (typeof col.accessor === 'function') return col.id\n              return col.accessor\n            })\n             const newOrder = cols.map(col => {\n              if (typeof col.accessor === 'function') return col.id\n              return col.accessor\n            })\n             // if order is not equal, then call onDraggedColumnChange prop\n            if (JSON.stringify(originalOrder) !== JSON.stringify(newOrder)) {\n              // pass back updated order of columns without added containing drag DIV\n              if (onDraggedColumnChange) onDraggedColumnChange(colsNoExtraContainingDiv)\n            }\n          }*/\n        // render\n\n        return React.createElement('div', {\n          className: 'rt-draggable-container',\n          ref: this.containerRef,\n          style: {\n            position: 'relative'\n          }\n        }, React.createElement(Component, _extends({}, rest, {\n          draggableColumns: draggableColumns,\n          columns: cols,\n          ref: function ref(r) {\n            return _this3.wrappedInstance = r;\n          }\n        })), reorderIndicatorUp, reorderIndicatorDown);\n      }\n    }]);\n    return RTFixedDraggableColumn;\n  }(React.Component);\n\n  var defaultProps = {\n    mode: DragMode.REORDER,\n    draggable: [],\n    enableColumnWideDrag: true,\n    disableTableScroll: false,\n    overflow: 'auto',\n    useDragImage: true,\n    dragImageClassName: 'rt-dragged-item',\n    onDragEnterClassName: 'rt-drag-enter-item',\n    reorderIndicatorUpClassName: '',\n    reorderIndicatorDownClassName: ''\n  };\n  wrapper.displayName = 'RTDraggableColumn';\n  wrapper.propTypes = {\n    draggableColumns: PropTypes.shape({\n      /** mode to either reorder the column or swap column position on drop */\n      mode: PropTypes.oneOf([DragMode.REORDER, DragMode.SWAP]).isRequired,\n\n      /** array of string-based column accessors or column ids (when using a custom accessor) to allow drag and drop */\n      draggable: PropTypes.arrayOf(PropTypes.string),\n\n      /** if {true} then entire header column is draggable.  If {false} then only header column text is draggable.\n       * Set to {false} if you experience buggyness when using with react-table column sorting/resizing functionality\n       */\n      enableColumnWideDrag: PropTypes.bool,\n\n      /** disable ReactTable horizontal/vertical scrolling when dragging a column */\n      disableTableScroll: PropTypes.bool,\n\n      /** used with disableTableScroll={true} to reset ReactTable overflow style onDragEnd event */\n      overflow: PropTypes.string,\n\n      /** clone dragged column?  useful for applying a different css class */\n      useDragImage: PropTypes.bool,\n\n      /** dragImageClassName only applies when useDragImage={true} */\n      dragImageClassName: PropTypes.string,\n\n      /** Swap mode only - css class */\n      onDragEnterClassName: PropTypes.string,\n\n      /** callback method to be notified when on column drop success - signature: function(draggedColumn, targetColumn, oldIndex, newIndex, oldOffset, newOffset)  */\n      onDropSuccess: PropTypes.func,\n\n      /** callback method to be notified when column order changes - signature: function(columns)  */\n      onDraggedColumnChange: PropTypes.func,\n\n      /** additional className for reorder indicator Up */\n      reorderIndicatorUpClassName: PropTypes.string,\n\n      /** additional className for reorder indicator Down */\n      reorderIndicatorDownClassName: PropTypes.string\n    })\n  };\n  return wrapper;\n};\n\nexport default index$1;\nexport { DragMode };","map":{"version":3,"sources":["../src/dom-helper.js","../src/index.js"],"names":["stripHtml","element","parseStrDimensionToInt","parseInt","getOffset","rect","el","document","scrollLeft","index","children","num","i","getAttribute","addClass","removeClass","className","hasClass","findFirstChildWithClassName","matches","findChildrenWithClassName","parentElement","getHiddenElementOuterHeight","elementHeight","getHiddenElementOuterWidth","elementWidth","getElementWidth","width","style","getComputedStyle","parseFloat","getElementHeight","height","DragMode","generateUuid","uuid","random","Math","wrapper","React","console","containerRef","currentColumnOrder","parent","header","DomHelper","headersCollection","headers","headerParent","enableColumnWideDrag","defaultProps","disableTableScroll","useDragImage","dragImageClassName","tableBody","crt","columnWidth","columnHeight","xOffSet","yOffSet","e","mode","onDragEnterClassName","dropHeader","containerOffset","dropHeaderOffset","targetLeft","columnCenter","tableBodyBoundingRec","maxVisibleXPos","minVisibleXPos","onDropSuccess","dragIndex","dropIndex","allowDrop","a","b","oldOffset","newOffset","trigger","firstLoad","overflow","onDraggedColumnChange","originalOrder","col","newOrder","JSON","origColumns","draggableColumns","rest","draggable","reorderIndicatorUpClassName","reorderIndicatorDownClassName","reorderIndicatorUp","position","display","reorderIndicatorDown","visibleColumns","hiddenColumns","adjustedOrigColumns","cols","headerClassName","Header","o","PropTypes","string"],"mappings":"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","sourcesContent":["const stripHtml = element => element.innerHTML.replace(/<[^>]*>?/gm, '')\n\nconst parseStrDimensionToInt = elementSize => parseInt(elementSize, 10)\n\nconst getOffset = el => {\n  var rect = el.getBoundingClientRect()\n\n  return {\n    top: rect.top + document.body.scrollTop,\n    left: rect.left + document.body.scrollLeft\n  }\n}\n\nconst index = element => {\n  let children = element.parentNode.childNodes\n  let num = 0\n  for (var i = 0; i < children.length; i++) {\n    if (children[i] === element) return num\n    if (children[i].nodeType === 1) num++\n  }\n  return -1\n}\n\nconst getAttribute = (element, attributeName) => {\n  return element.getAttribute(attributeName)\n}\n\nconst addClass = (element, className) => {\n  if (element.classList) element.classList.add(className)\n  else element.className += ' ' + className\n}\n\nconst removeClass = (element, className) => {\n  if (element.classList) element.classList.remove(className)\n  else {\n    element.className = element.className.replace(\n      new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'),\n      ' '\n    )\n  }\n}\n\nconst hasClass = (element, className) => {\n  if (element.classList) return element.classList.contains(className)\n  else return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className)\n}\n\nconst findFirstChildWithClassName = (element, className) => {\n  const matches = element.getElementsByClassName(className)\n\n  if (matches && matches.length > 0) return matches[0]\n\n  return null\n}\n\nconst findChildrenWithClassName = (parentElement, className) => {\n  return parentElement.getElementsByClassName(className)\n}\n\nconst getHiddenElementOuterHeight = element => {\n  element.style.visibility = 'hidden'\n  element.style.display = 'block'\n  let elementHeight = element.offsetHeight\n  element.style.display = 'none'\n  element.style.visibility = 'visible'\n\n  return elementHeight\n}\n\nconst getHiddenElementOuterWidth = element => {\n  element.style.visibility = 'hidden'\n  element.style.display = 'block'\n  let elementWidth = element.offsetWidth\n  element.style.display = 'none'\n  element.style.visibility = 'visible'\n\n  return elementWidth\n}\n\nconst getElementWidth = el => {\n  let width = el.offsetWidth\n  let style = getComputedStyle(el)\n\n  width -=\n    parseFloat(style.paddingLeft) +\n    parseFloat(style.paddingRight) +\n    parseFloat(style.borderLeftWidth) +\n    parseFloat(style.borderRightWidth)\n\n  return width\n}\n\nconst getElementHeight = el => {\n  let height = el.offsetHeight\n  let style = getComputedStyle(el)\n\n  height -=\n    parseFloat(style.paddingTop) +\n    parseFloat(style.paddingBottom) +\n    parseFloat(style.borderTopWidth) +\n    parseFloat(style.borderBottomWidth)\n\n  return height\n}\n\nexport default {\n  stripHtml,\n  parseStrDimensionToInt,\n  getOffset,\n  index,\n  getAttribute,\n  addClass,\n  removeClass,\n  hasClass,\n  getHiddenElementOuterHeight,\n  getHiddenElementOuterWidth,\n  findFirstChildWithClassName,\n  findChildrenWithClassName,\n  getElementWidth,\n  getElementHeight\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport DomHelper from './dom-helper'\nimport './styles.scss'\n\nexport const DragMode = {\n  REORDER: 'reorder',\n  SWAP: 'swap'\n}\n\n/**\n * Generate UuId\n * */\nconst generateUuid = () => {\n  let uuid = ''\n  let i\n  let random\n  for (i = 0; i < 32; i++) {\n    random = (Math.random() * 16) | 0\n\n    if (i === 8 || i === 12 || i === 16 || i === 20) {\n      uuid += '-'\n    }\n    uuid += (i === 12 ? 4 : i === 16 ? (random & 3) | 8 : random).toString(16)\n  }\n\n  return uuid\n}\n\nexport default Component => {\n  const wrapper = class RTFixedDraggableColumn extends React.Component {\n    getWrappedInstance() {\n      if (!this.wrappedInstance) console.warn('RTDraggableColumn - No wrapped instance')\n      if (this.wrappedInstance.getWrappedInstance) return this.wrappedInstance.getWrappedInstance()\n      else return this.wrappedInstance\n    }\n\n    containerRef = React.createRef();\n    currentColumnOrder = [];\n\n    constructor(props) {\n      super(props)\n      this.dragged = null\n      this.reorder = []\n      this.colsNoExtraContainingDiv = []\n      this.state = {\n        trigger: 0,\n        firstLoad: true\n      }\n\n      this.uniqueId = generateUuid()\n    }\n\n    // helper methods\n    findParentHeader(element) {\n      // need to check typeof to avoid errors when traversing special elements like SVGs\n      if (element.className && typeof element.className === 'string' && element.className.includes('rt-th')) {\n        return element\n      } else {\n        let parent = element.parentElement\n        while (typeof parent.className !== 'string' || !parent.className.includes('rt-th')) {\n          parent = parent.parentElement\n          if (!parent) break\n        }\n        return parent\n      }\n    }\n\n    getFirstChildWithColumnIndexAttributeValue(element) {\n      const header = DomHelper.findFirstChildWithClassName(element, 'draggable-header')\n\n      if (header) {\n        return DomHelper.getAttribute(header, 'data-column-index')\n      }\n    }\n    // end helper methods\n\n    createDragEvents() {\n      const headersCollection = DomHelper.findChildrenWithClassName(\n        this.containerRef.current,\n        `${this.uniqueId} draggable-header`\n      )\n\n      // convert HTML collection to Javascript array\n      const headers = [...headersCollection]\n\n      headers.forEach((header, i) => {\n        // only allow drag events on drag enabled columns\n        if (header.className.includes('enable-drag')) {\n          const headerParent = header.parentNode\n\n          const {\n            draggableColumns: { enableColumnWideDrag = defaultProps.enableColumnWideDrag }\n          } = this.props\n\n          if (enableColumnWideDrag) {\n            headerParent.setAttribute('draggable', true)\n          } else {\n            header.setAttribute('draggable', true)\n            DomHelper.addClass(headerParent, 'transparent-border')\n          }\n\n          // ondragstart event\n          headerParent.ondragstart = e => {\n            e.stopPropagation()\n\n            const {\n              draggableColumns: {\n                disableTableScroll,\n                useDragImage = defaultProps.useDragImage,\n                dragImageClassName = defaultProps.dragImageClassName\n              }\n            } = this.props\n\n            if (disableTableScroll) {\n              const tableBody = DomHelper.findFirstChildWithClassName(\n                this.containerRef.current,\n                'rt-table'\n              )\n\n              if (tableBody) {\n                tableBody.style.overflow = 'hidden'\n              }\n            }\n\n            // counter used as a workaround for dragleave event fired when hovering over a child element\n            this.counter = 0\n            this.dragged = i\n            this.draggedName = DomHelper.stripHtml(headerParent)\n            this.draggedColumn = this.findParentHeader(headerParent)\n\n            this.iconWidth = DomHelper.getHiddenElementOuterWidth(this.reorderIndicatorUp)\n            this.iconHeight = DomHelper.getHiddenElementOuterHeight(this.reorderIndicatorUp)\n\n            e.dataTransfer.setData('text', 'b') // Firefox requires this to make dragging possible\n\n            if (useDragImage) {\n              const crt = this.draggedColumn.cloneNode(true)\n\n              crt.className = dragImageClassName\n              const columnWidth = DomHelper.getElementWidth(this.draggedColumn)\n              const columnHeight = DomHelper.getElementHeight(this.draggedColumn)\n\n              // calculate offset from draggedColumn element\n              let xOffSet = Math.floor(columnWidth / 2)\n              const yOffSet = Math.floor(columnHeight / 2)\n\n              // max-width of 150px, otherwise it looks blurry in Chrome (Windows)\n              if (columnWidth > 150) {\n                crt.style.width = '150px'\n                xOffSet = 150 / 2\n              }\n\n              crt.style.position = 'absolute'\n              crt.style.top = '-1000px'\n\n              document.body.appendChild(crt)\n              e.dataTransfer.effectAllowed = 'move'\n              e.dataTransfer.setDragImage(crt, xOffSet, yOffSet)\n\n              // set refernce to cloned Node\n              this.clone = crt\n            }\n          }\n\n          // ondrag event\n          headerParent.ondrag = e => {\n            e.stopPropagation()\n          }\n\n          headerParent.ondragenter = e => {\n            e.stopPropagation()\n            e.preventDefault()\n            this.counter++\n\n            if (DomHelper.stripHtml(e.target) !== this.draggedName) {\n              const {\n                draggableColumns: {\n                  mode = defaultProps.mode,\n                  onDragEnterClassName = defaultProps.onDragEnterClassName\n                }\n              } = this.props\n\n              if (mode === DragMode.SWAP && onDragEnterClassName) {\n                const dropHeader = this.findParentHeader(e.target)\n                DomHelper.addClass(dropHeader.firstChild, onDragEnterClassName)\n              }\n            }\n          }\n\n          // ondragover event\n          headerParent.ondragover = e => {\n            e.preventDefault()\n\n            // prevent bug when using multiple react tables\n            if (!this.draggedColumn) return\n\n            const {\n              draggableColumns: { mode = defaultProps.mode }\n            } = this.props\n\n            const dropHeader = this.findParentHeader(e.target)\n\n            // in reorder mode only\n            if (mode === DragMode.REORDER) {\n              if (DomHelper.stripHtml(e.target) !== this.draggedName) {\n                const containerOffset = DomHelper.getOffset(this.containerRef.current)\n                const dropHeaderOffset = DomHelper.getOffset(dropHeader)\n                const targetLeft = dropHeaderOffset.left - containerOffset.left\n                const columnCenter = dropHeaderOffset.left + dropHeader.offsetWidth / 2\n\n                const tableBodyBoundingRec = DomHelper.findFirstChildWithClassName(\n                  this.containerRef.current,\n                  'rt-table'\n                ).getBoundingClientRect()\n\n                // determine current table viewport\n                const maxVisibleXPos = tableBodyBoundingRec.right\n                const minVisibleXPos = 0 - Math.ceil(this.iconWidth / 2)\n\n                this.reorderIndicatorUp.style.top =\n                  dropHeaderOffset.top - containerOffset.top - (this.iconHeight + 3) + 'px'\n\n                this.reorderIndicatorDown.style.top =\n                  dropHeaderOffset.top - containerOffset.top + dropHeader.offsetHeight + 3 + 'px'\n\n                if (e.pageX > columnCenter) {\n                  this.reorderIndicatorUp.style.left =\n                    targetLeft + dropHeader.offsetWidth - Math.ceil(this.iconWidth / 2) + 'px'\n                  this.reorderIndicatorDown.style.left =\n                    targetLeft + dropHeader.offsetWidth - Math.ceil(this.iconWidth / 2) + 'px'\n                  this.dropPosition = 1\n                } else {\n                  this.reorderIndicatorUp.style.left =\n                    targetLeft - Math.ceil(this.iconWidth / 2) + 'px'\n                  this.reorderIndicatorDown.style.left =\n                    targetLeft - Math.ceil(this.iconWidth / 2) + 'px'\n\n                  this.dropPosition = -1\n                }\n\n                if (\n                  DomHelper.parseStrDimensionToInt(this.reorderIndicatorUp.style.left) >\n                    maxVisibleXPos ||\n                  DomHelper.parseStrDimensionToInt(this.reorderIndicatorUp.style.left) <\n                    minVisibleXPos\n                ) {\n                  // do not show indicators if position is outside leftmost or rightmost bounds of the react table\n                  this.reorderIndicatorUp.style.display = 'none'\n                  this.reorderIndicatorDown.style.display = 'none'\n                } else {\n                  this.reorderIndicatorUp.style.display = 'block'\n                  this.reorderIndicatorDown.style.display = 'block'\n                  this.reorderIndicatorUp.style.zIndex = 50\n                  this.reorderIndicatorDown.style.zIndex = 50\n                }\n              }\n            }\n          }\n\n          headerParent.ondragleave = e => {\n            e.preventDefault()\n\n            this.counter--\n\n            const {\n              draggableColumns: {\n                mode = defaultProps.mode,\n                onDragEnterClassName = defaultProps.onDragEnterClassName\n              }\n            } = this.props\n\n            if (mode === DragMode.REORDER) {\n              if (this.counter === 0) {\n                this.reorderIndicatorUp.style.display = 'none'\n                this.reorderIndicatorDown.style.display = 'none'\n              }\n            } else if (mode === DragMode.SWAP) {\n              if (this.counter === 0 && onDragEnterClassName) {\n                const dropHeader = this.findParentHeader(e.target)\n                DomHelper.removeClass(dropHeader.firstChild, onDragEnterClassName)\n              }\n            }\n          }\n\n          // ondrop event\n          headerParent.ondrop = e => {\n            e.preventDefault()\n\n            // prevent bug when using multiple react tables\n            if (!this.draggedColumn) return\n\n            const {\n              draggableColumns: { mode = defaultProps.mode, onDropSuccess }\n            } = this.props\n\n            if (mode === DragMode.REORDER) {\n              // only move if the dragged column is meets position threshold\n              let dragIndex = DomHelper.index(this.draggedColumn)\n              let dropIndex = DomHelper.index(this.findParentHeader(e.target))\n\n              // for the future\n              // this.getFirstChildWithColumnIndexAttributeValue(this.draggedColumn)\n\n              let allowDrop = dragIndex !== dropIndex\n\n              if (\n                allowDrop &&\n                ((dropIndex - dragIndex === 1 && this.dropPosition === -1) ||\n                  (dragIndex - dropIndex === 1 && this.dropPosition === 1))\n              ) {\n                allowDrop = false\n              }\n\n              if (allowDrop) {\n                // readjust dropIndex value for edge cases\n                // if dragging a column from left to right\n                if (this.dragged < dropIndex) {\n                  if (this.dropPosition === -1) {\n                    dropIndex = dropIndex - 1\n                  }\n                } else {\n                  // dragging a column from right to left\n                  if (this.dropPosition === 1) {\n                    dropIndex = dropIndex + 1\n                  }\n                }\n\n                this.reorder.push({ a: dropIndex, b: this.dragged })\n\n                if (onDropSuccess) {\n                  const containerOffset = DomHelper.getOffset(this.containerRef.current)\n\n                  // adjust offSets to be respective to the containerOffset\n                  const oldOffset = DomHelper.getOffset(this.draggedColumn)\n                  oldOffset.top = oldOffset.top - containerOffset.top\n                  oldOffset.left = oldOffset.left - containerOffset.left\n\n                  const newOffset = DomHelper.getOffset(this.findParentHeader(e.target))\n                  newOffset.top = newOffset.top - containerOffset.top\n                  newOffset.left = newOffset.left - containerOffset.left\n\n                  // (draggedColumn, targetColumn, oldIndex, newIndex, oldOffset, newOffset)\n                  onDropSuccess(\n                    this.colsNoExtraContainingDiv[this.dragged],\n                    this.colsNoExtraContainingDiv[dropIndex],\n                    this.dragged,\n                    dropIndex,\n                    oldOffset,\n                    newOffset\n                  )\n                }\n              }\n            } else if (mode === DragMode.SWAP) {\n              this.reorder.push({ a: i, b: this.dragged })\n\n              if (onDropSuccess) {\n                // (draggedColumn, targetColumn, oldIndex, newIndex)\n                onDropSuccess(\n                  this.currentColumnOrder[this.dragged],\n                  this.currentColumnOrder[i],\n                  this.dragged,\n                  i\n                )\n              }\n            }\n\n            this.dragged = null\n            this.draggedName = null\n            this.draggedColumn = null\n            this.dropPosition = null\n            this.counter = 0\n            this.reorderIndicatorUp.style.display = 'none'\n            this.reorderIndicatorDown.style.display = 'none'\n            // trigger a re-render\n            this.setState({ trigger: Math.random(), firstLoad: false })\n          }\n\n          // ondragend event\n          headerParent.ondragend = e => {\n            const {\n              draggableColumns: { disableTableScroll, overflow }\n            } = this.props\n\n            e.stopPropagation()\n\n            if (this.clone) {\n              document.body.removeChild(this.clone)\n              this.clone = null\n            }\n\n            if (disableTableScroll) {\n              const tableBody = DomHelper.findFirstChildWithClassName(\n                this.containerRef.current,\n                'rt-table'\n              )\n\n              if (tableBody) {\n                tableBody.style.overflow = overflow || defaultProps.overflow\n              }\n            }\n          }\n        }\n      })\n    }\n\n    componentDidMount() {\n      if (this.props.draggableColumns.draggable.length > 0) this.createDragEvents()\n    }\n\n    componentDidUpdate() {\n      const { onDraggedColumnChange } = this.props.draggableColumns\n      if (!this.state.firstLoad) {\n        const originalOrder = this.previousOrder.map((col) => {\n          if (typeof col.accessor === 'function') return col.id\n          return col.accessor\n        })\n\n        const newOrder = this.currentColumnOrder.map((col) => {\n          if (typeof col.accessor === 'function') return col.id\n          return col.accessor\n        })\n\n        // if order is not equal, then call onDraggedColumnChange prop\n        if (JSON.stringify(originalOrder) !== JSON.stringify(newOrder)) {\n          // pass back updated order of columns without added containing drag DIV\n          if (onDraggedColumnChange) {\n            onDraggedColumnChange(this.colsNoExtraContainingDiv)\n          }\n        }\n      }\n\n      if (this.props.draggableColumns.draggable.length > 0) this.createDragEvents()\n    }\n\n    // prevent side effects such as accidentally resizing column while dragging a column\n    stopPropagation = e => {\n      e.stopPropagation()\n    };\n\n    render() {\n      const { columns: origColumns, draggableColumns, ...rest } = this.props\n      const {\n        draggable = defaultProps.draggable,\n        mode = defaultProps.mode,\n        reorderIndicatorUpClassName = defaultProps.reorderIndicatorUpClassName,\n        reorderIndicatorDownClassName = defaultProps.reorderIndicatorDownClassName\n      } = draggableColumns\n\n      let reorderIndicatorUp = (\n        <span\n          ref={el => {\n            this.reorderIndicatorUp = el\n          }}\n          className={`arrow arrow-bar is-top ${reorderIndicatorUpClassName}`}\n          style={{ position: 'absolute', display: 'none' }}\n        />\n      )\n\n      let reorderIndicatorDown = (\n        <span\n          ref={el => {\n            this.reorderIndicatorDown = el\n          }}\n          className={`arrow arrow-bar is-bottom ${reorderIndicatorDownClassName}`}\n          style={{ position: 'absolute', display: 'none' }}\n        />\n      )\n\n      // separate out visible and hidden columns\n      const visibleColumns = origColumns.filter(col => col.show === true || col.show === undefined)\n      const hiddenColumns = origColumns.filter(col => col.show === false)\n\n      // place hidden columns at very end of array\n      // having a hidden column inbetween two draggable columns will cause this HOC to improperly calculate the new column index positions\n      const adjustedOrigColumns = [...visibleColumns, ...hiddenColumns]\n      // shallow copy of columns without added containing drag DIV\n      this.colsNoExtraContainingDiv = [...adjustedOrigColumns]\n      const cols = adjustedOrigColumns.map((col, index) => {\n        let headerClassName = `${this.uniqueId} draggable-header`\n\n        // add additional className if column is draggable enabled\n        if (\n          (draggable.length > 0 && draggable.includes(col.id)) ||\n          draggable.includes(col.accessor)\n        ) {\n          headerClassName = `${headerClassName} enable-drag`\n        }\n\n        return {\n          ...col,\n          Header:\n            typeof col.Header === 'function' ? (\n              <div className={headerClassName} data-column-index={index}>\n                {col.Header()}\n              </div>\n            ) : (\n              <div className={headerClassName} data-column-index={index}>\n                {col.Header}\n              </div>\n            )\n        }\n      })\n\n      //const previousOrder = [...this.currentColumnOrder]\n      this.previousOrder = [...this.currentColumnOrder]\n\n      // run all reorder events\n      if (mode && mode === DragMode.SWAP) {\n        this.reorder.forEach(o => (cols[o.a] = cols.splice(o.b, 1, cols[o.a])[0]))\n        this.reorder.forEach(o => (this.colsNoExtraContainingDiv[o.a] = this.colsNoExtraContainingDiv.splice(o.b, 1, this.colsNoExtraContainingDiv[o.a])[0]))\n      } else {\n        // mode: reorder - default\n        this.reorder.forEach(o => cols.splice(o.a, 0, cols.splice(o.b, 1)[0]))\n        this.reorder.forEach(o => this.colsNoExtraContainingDiv.splice(o.a, 0, this.colsNoExtraContainingDiv.splice(o.b, 1)[0]))\n      }\n\n      // track final column order\n      this.currentColumnOrder = cols\n\n      // fire change event?\n    /*  if (!this.state.firstLoad) {\n        const originalOrder = this.previousOrder.map(col => {\n          if (typeof col.accessor === 'function') return col.id\n          return col.accessor\n        })\n\n        const newOrder = cols.map(col => {\n          if (typeof col.accessor === 'function') return col.id\n          return col.accessor\n        })\n\n        // if order is not equal, then call onDraggedColumnChange prop\n        if (JSON.stringify(originalOrder) !== JSON.stringify(newOrder)) {\n          // pass back updated order of columns without added containing drag DIV\n          if (onDraggedColumnChange) onDraggedColumnChange(colsNoExtraContainingDiv)\n        }\n      }*/\n\n      // render\n      return (\n        <div\n          className='rt-draggable-container'\n          ref={this.containerRef}\n          style={{ position: 'relative' }}\n        >\n          <Component\n            {...rest}\n            draggableColumns={draggableColumns}\n            columns={cols}\n            ref={r => (this.wrappedInstance = r)}\n          />\n          {reorderIndicatorUp}\n          {reorderIndicatorDown}\n        </div>\n      )\n    }\n  }\n\n  const defaultProps = {\n    mode: DragMode.REORDER,\n    draggable: [],\n    enableColumnWideDrag: true,\n    disableTableScroll: false,\n    overflow: 'auto',\n    useDragImage: true,\n    dragImageClassName: 'rt-dragged-item',\n    onDragEnterClassName: 'rt-drag-enter-item',\n    reorderIndicatorUpClassName: '',\n    reorderIndicatorDownClassName: ''\n  }\n\n  wrapper.displayName = 'RTDraggableColumn'\n\n  wrapper.propTypes = {\n    draggableColumns: PropTypes.shape({\n      /** mode to either reorder the column or swap column position on drop */\n      mode: PropTypes.oneOf([DragMode.REORDER, DragMode.SWAP]).isRequired,\n      /** array of string-based column accessors or column ids (when using a custom accessor) to allow drag and drop */\n      draggable: PropTypes.arrayOf(PropTypes.string),\n      /** if {true} then entire header column is draggable.  If {false} then only header column text is draggable.\n       * Set to {false} if you experience buggyness when using with react-table column sorting/resizing functionality\n       */\n      enableColumnWideDrag: PropTypes.bool,\n      /** disable ReactTable horizontal/vertical scrolling when dragging a column */\n      disableTableScroll: PropTypes.bool,\n      /** used with disableTableScroll={true} to reset ReactTable overflow style onDragEnd event */\n      overflow: PropTypes.string,\n      /** clone dragged column?  useful for applying a different css class */\n      useDragImage: PropTypes.bool,\n      /** dragImageClassName only applies when useDragImage={true} */\n      dragImageClassName: PropTypes.string,\n      /** Swap mode only - css class */\n      onDragEnterClassName: PropTypes.string,\n      /** callback method to be notified when on column drop success - signature: function(draggedColumn, targetColumn, oldIndex, newIndex, oldOffset, newOffset)  */\n      onDropSuccess: PropTypes.func,\n      /** callback method to be notified when column order changes - signature: function(columns)  */\n      onDraggedColumnChange: PropTypes.func,\n      /** additional className for reorder indicator Up */\n      reorderIndicatorUpClassName: PropTypes.string,\n      /** additional className for reorder indicator Down */\n      reorderIndicatorDownClassName: PropTypes.string\n    })\n  }\n\n  return wrapper\n}\n"]},"metadata":{},"sourceType":"module"}