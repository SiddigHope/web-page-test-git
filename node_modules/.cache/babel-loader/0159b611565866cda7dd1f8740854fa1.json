{"ast":null,"code":"import hotkeys from 'hotkeys-js';\nimport { useRef, useCallback, useEffect } from 'react';\n\nfunction useIsHotkeyPressed() {\n  return hotkeys.isPressed;\n}\n\nhotkeys.filter = function () {\n  return true;\n};\n\nvar tagFilter = function tagFilter(_ref, enableOnTags) {\n  var target = _ref.target;\n  var targetTagName = target && target.tagName;\n  return Boolean(targetTagName && enableOnTags && enableOnTags.includes(targetTagName));\n};\n\nvar isKeyboardEventTriggeredByInput = function isKeyboardEventTriggeredByInput(ev) {\n  return tagFilter(ev, ['INPUT', 'TEXTAREA', 'SELECT']);\n};\n\nfunction useHotkeys(keys, callback, options, deps) {\n  if (options instanceof Array) {\n    deps = options;\n    options = undefined;\n  }\n\n  var _ref2 = options || {},\n      enableOnTags = _ref2.enableOnTags,\n      filter = _ref2.filter,\n      keyup = _ref2.keyup,\n      keydown = _ref2.keydown,\n      _ref2$filterPreventDe = _ref2.filterPreventDefault,\n      filterPreventDefault = _ref2$filterPreventDe === void 0 ? true : _ref2$filterPreventDe,\n      _ref2$enabled = _ref2.enabled,\n      enabled = _ref2$enabled === void 0 ? true : _ref2$enabled;\n\n  var ref = useRef(null);\n  var memoisedCallback = useCallback(function (keyboardEvent, hotkeysEvent) {\n    var _keyboardEvent$target;\n\n    if (filter && !filter(keyboardEvent)) {\n      return !filterPreventDefault;\n    }\n\n    if (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags) || (_keyboardEvent$target = keyboardEvent.target) != null && _keyboardEvent$target.isContentEditable) {\n      return true;\n    }\n\n    if (ref.current === null || document.activeElement === ref.current) {\n      callback(keyboardEvent, hotkeysEvent);\n      return true;\n    }\n\n    return false;\n  }, deps ? [ref, enableOnTags, filter].concat(deps) : [ref, enableOnTags, filter]);\n  useEffect(function () {\n    if (!enabled) {\n      return;\n    }\n\n    if (keyup && keydown !== true) {\n      options.keydown = false;\n    }\n\n    hotkeys(keys, options || {}, memoisedCallback);\n    return function () {\n      return hotkeys.unbind(keys, memoisedCallback);\n    };\n  }, [memoisedCallback, options, keys, enabled]);\n  return ref;\n}\n\nexport { useHotkeys, useIsHotkeyPressed };","map":{"version":3,"sources":["../src/useIsHotkeyPressed.ts","../src/useHotkeys.ts"],"names":["useIsHotkeyPressed","hotkeys","tagFilter","target","targetTagName","Boolean","enableOnTags","isKeyboardEventTriggeredByInput","useHotkeys","keys","callback","options","deps","filter","keyup","keydown","filterPreventDefault","enabled","ref","useRef","memoisedCallback","useCallback","keyboardEvent","document","useEffect"],"mappings":"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","sourcesContent":["import hotkeys from 'hotkeys-js';\n\nexport function useIsHotkeyPressed() {\n  return hotkeys.isPressed;\n}","import hotkeys, { HotkeysEvent, KeyHandler } from 'hotkeys-js';\nimport React, { useCallback, useEffect, useRef } from 'react';\n\ntype AvailableTags = 'INPUT' | 'TEXTAREA' | 'SELECT';\n\n// We implement our own custom filter system.\nhotkeys.filter = () => true;\n\nconst tagFilter = ({ target }: KeyboardEvent, enableOnTags?: AvailableTags[]) => {\n  const targetTagName = target && (target as HTMLElement).tagName;\n\n  return Boolean((targetTagName && enableOnTags && enableOnTags.includes(targetTagName as AvailableTags)));\n};\n\nconst isKeyboardEventTriggeredByInput = (ev: KeyboardEvent) => {\n  return tagFilter(ev, ['INPUT', 'TEXTAREA', 'SELECT']);\n};\n\nexport type Options = {\n  enabled?: boolean;\n  filter?: typeof hotkeys.filter;\n  filterPreventDefault?: boolean;\n  enableOnTags?: AvailableTags[];\n  splitKey?: string;\n  scope?: string;\n  keyup?: boolean;\n  keydown?: boolean;\n};\n\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: Options): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, deps?: any[]): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: Options, deps?: any[]): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: any[] | Options, deps?: any[]): React.MutableRefObject<T | null> {\n  if (options instanceof Array) {\n    deps = options;\n    options = undefined;\n  }\n\n  const {\n    enableOnTags,\n    filter,\n    keyup,\n    keydown,\n    filterPreventDefault = true,\n    enabled = true,\n  } = options as Options || {};\n  const ref = useRef<T | null>(null);\n\n  const memoisedCallback = useCallback((keyboardEvent: KeyboardEvent, hotkeysEvent: HotkeysEvent) => {\n    if (filter && !filter(keyboardEvent)) {\n      return !filterPreventDefault;\n    }\n\n    if (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags) || (keyboardEvent.target as HTMLElement)?.isContentEditable) {\n      return true;\n    }\n\n    if (ref.current === null || document.activeElement === ref.current) {\n      callback(keyboardEvent, hotkeysEvent);\n      return true;\n    }\n\n    return false;\n  }, deps ? [ref, enableOnTags, filter, ...deps] : [ref, enableOnTags, filter]);\n\n  useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (keyup && keydown !== true) {\n      (options as Options).keydown = false;\n    }\n\n    hotkeys(keys, (options as Options) || {}, memoisedCallback);\n\n    return () => hotkeys.unbind(keys, memoisedCallback);\n  }, [memoisedCallback, options, keys, enabled]);\n\n  return ref;\n}\n"]},"metadata":{},"sourceType":"module"}